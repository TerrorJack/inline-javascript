# inline-js: execute Node.js scripts in Haskell

[![CircleCI](https://circleci.com/gh/tweag/inline-js/tree/master.svg?style=shield)](https://circleci.com/gh/tweag/inline-js/tree/master)
[![AppVeyor](https://ci.appveyor.com/api/projects/status/github/tweag/inline-js?branch=master&svg=true)](https://ci.appveyor.com/project/tweag/inline-js?branch=master)

**NOTE: this is alpha quality software. Please don't publicize widely.**

## Usage

### Adding dependency

First, add `inline-js` to the [`custom-setup`](https://cabal.readthedocs.io/en/latest/developing-packages.html#custom-setup-scripts) stanza of your package's `.cabal` config. The `Setup.hs` script looks like:

```haskell
import Language.JavaScript.Inline.Configure

main :: IO ()
main = defaultMainWithInlineJS defaultConfigureOptions
```

This will execute some additional post-configure actions when building your package, for example running `npm install` to initialize the eval server. The initialization will be performed only once if your package is built without re-configuring. The `ConfigureOptions` type in `Language.JavaScript.Inline.Configure` provide several fields to customize the initialization, for example, specifying a minimum `node` version, supplying additional environment variables or running custom shell commands.

If you need to add `npm` dependencies, you can add them like this:

```haskell
{-# LANGUAGE OverloadedStrings #-}

import Language.JavaScript.Inline.Configure

main :: IO ()
main = defaultMainWithInlineJS $ defaultConfigureOptions { commands = ["npm install left-pad"] }
```

Then, add `inline-js` as a regular dependency for your build target. The above `Setup.hs` scripts will produce a `.buildinfo` file in the project directory, so you may want to add it to the `.gitignore`.

### Usage

```haskell
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

import Control.Exception
import Data.Aeson
import Language.JavaScript.Inline

main :: IO ()
main = do
  s <- newSession $(configureOptionsQ)
  flip finally (closeSession s) $ do
    nul <- eval s "let answer = 6 * 7"
    print (nul :: Value)
    answer <- eval s "answer"
    print (answer :: Double)
    tmpdir <- eval s "require('os').tmpdir()"
    print (tmpdir :: String)
    async <-
      eval
        s
        [js|new Promise((resolve, reject) => resolve('the answer is: ' + {{answer}}))|]
    print (async :: String)
```

Executing `newSession` will start the eval server. An eval server has a single V8 execution context, and bindings are shared across multiple `eval` calls. `require` is available. `newSession` requires a `ConfigureOptions` value which should not be written by hand, but supplied by using the `$(configureOptionsQ)` splice, which fetches the value from `.buildinfo` generated by our custom `Setup.hs` script.

`eval` accepts `Text` as a JavaScript source code, performs evaluation and returns the result. The result is marshalled to the Haskell world with a `FromJSON` instance, so you may need to annotate the result type if it can't be inferred from the context. Evaluation failure will raise an exception.

You can use the `js` quasi-quoter to embed inline JavaScript in Haskell. The inline JavaScript snippet can contain interpolations like `{{var}}`. `var` is a Haskell binding in scope, and it will be marshalled from the Haskell world with a `ToJSON` instance.

`closeSession` will terminate the eval server. Remember to use a `bracket`-like function to make sure the finalizer is invoked even in case of exception, to prevent dangling `node` processes.

The above demo is included in [`examples`](examples). The haddock documentation of the `master` branch is available [here](https://tweag.github.io/inline-js/inline-js-0.0.1/index.html).

## Sponsors

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[![Tweag I/O](https://www.tweag.io/img/tweag-small.png)](https://www.tweag.io)

inline-js is maintained by [Tweag I/O](https://tweag.io/).

Have questions? Need help? Tweet at
[@tweagio](https://twitter.com/tweagio).
